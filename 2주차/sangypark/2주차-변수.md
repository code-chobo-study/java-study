# 변수란?

프로그램이 작업을 처리하는 과정에서 필요한 데이터가 필요한데 이를 메모리에 저장해야한다. 이때 이런 데이터를 변수라고 한다. 즉, `변수`는 `값을 저장할 수 있는 메모리 공간`이다. 변수를 선언한다는것은 값을 저장할 공간을 마련하는 것이다. 변수에 값을 할당한다는 것은 확보된 메모리 공간에 값을 저장한다는 것이다.

# 변수의 종류

`인스턴스 변수`는 클래스 영역에 선언되고, 클래스 인스턴스가 생성될때 만들어진다.

`클래스 변수`는 클래스 영역에 선언되지만 `static` 키워드가 붙어있는 변수이다. 정적으로 메모리에 한번만 올라가고 인스턴스 생성 없이 클래스자체에 직접 접근해서 사용이 가능하다.

`지역변수`는 메서드 내에 선언되어 메서드 내에서만 가능하고 메서드가 종료되면 소멸된다.  또한, 지역변수는 다른 변수와 다르게 선언과 동시에 값을 초기화 해야한다,

# 변수의 스코프와 라이프타임

우리는 위에서 변수라는 개념을 알게되었다. 이제 자바라는 언어에 존재하는 변수의 종류를 알아보고 각 변수가 가지는 스코프와 라이프타임을 정리해보자. 자바에서는 변수 선언 위치에 따라서 스코프와 라이프타임이 다르다.

```java
public class A {
	private int instanceValue; //인스턴스 변수 (생성한 인스턴스 내부에서만 유효)
	public static int classValue;//클래스 변수(static, 공유 변수) (클래스 영역에서 유효)

	public void method(){
		int localValue = 0; //지역 변수 (해당 메서드 내부에서만 유효)
	}
}
```

# 클래스변수,인스턴스 변수, 지역변수가 메모리에 올라가는 과정에 대해서

```java
class Person {
    int id;
    String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class PersonBuilder {
    private static Person buildPerson(int id, String name) {
        return new Person(id, name);
    }

    public static void main(String[] args) {
        int id = 23;
        String name = "John";
        Person person = null;
        person = buildPerson(id, name);
    }
}
```

![](https://images.velog.io/images/seong-dodo/post/b81f6f25-05f1-4cae-81df-588406a424b6/image.png)

# 변수의 타입

저장할 값의 타입에 따라서 적절한 타입에 데이터를 저장해야한다. 이를 위해 자바에서는 여러가지 형태의 변수 타입을 제공한다. 기본적으로 자바에서는 기본형과 참조형이 있다. 기본형에 대해서 먼저 정리하고 참조형에 대해서 알아보자.

## 비트와 바이트

변수의 타입을 알아보기전에 간단하게 비트와 바이트에 대해서 알아보자.

- 2진수의 0과1을 표현하는 각 자리수 : 비트
- 비트 8개가 모이면 ? : 바이트
- 컴퓨터는 일반적으로 8개의 비트를 하나의 그륩으로 묶은 바이트를 사용

## 기본형

- 논리형,문자형,정수형,실수형을 위한 타입이다.
    - `boolean`, `char`,  `byte` , `short` , `int` , `long` , `float` , `double`
    - boolean은 true,false만 표현하므로 1byte
    - char는 자바에서 유니코드(2byte)를 사용하기에 2byte
    - byte는 크기가 1byte이므로 1byte
    - short는 2바이트
    - int는 4바이트
    - long은 8바이트
    - float는 부동소수점 방식으로 저장 (4byte)
    - double은 float보다 두 배의 크기(8byte)를 갖는다.
- 메모리 스택영역에 값이 저장

## 논리형(boolean)

Java 에서는 논리형 자료로 `boolean`을 제공한다. `true`와 `false`를 나타낸다. 다른 기본형과의 연산은 불가능한 특징이 있다. 크기는 1byte이다.

## 문자형(char)

컴퓨터는 0,1만 알고 있는 기계이다. 따라서 문자형도 결국에는 0,1로 저장이 된다. 내부적으로는 유니코드 / 아스키코드 로 맵핑시켜서 저장을 시킨다. 따라서 실수형이나 정수형과 연산이 가능한 특징이 있다. 크기는 2byte이다.

## 정수형 (int,byte,short,long)

- long : 8byte
- int : 4byte
- byte : 1byte
- short : 2byte

정수형 타입은 리터럴 접미사가 붙지않으면 int타입으로 간주한다. 이때, 왜 기본형 타입을 int로 가질까? 이것은 `JVM의 피연산자 스택(operand stack)`이 `피연산자를 4byte단위로 저장`하기 때문에 4byte보다 작은 자료형(byte,short)로 값을 계산하면 4byte로 변환하여 연산을 수행한다. 즉, int자료형을 사용하면 바로 연산을 하지만 4byte보다 작은 자료형을 사용하면 연산을 위해서 다시한번 int형으로 변환하는 연산이 생기게 된다. 따라서, 연산을 수행할때 int보다 작은 자료형을 사용하면 더 비효율적인것이다. 만약, `CPU연산`보다 `메모리를 더 절약하는게 중요한 프로그램이라면 byte,short`를 사용해도 된다.

## 실수형(float,double)

- float : 4byte
- double : 8byte

실수형을 저장하는 자료형에는 float,double이 있다. 일반적으로 float타입보다는 double타입을 더 많이 사용한다. 이는 높은 `정밀도`가 필요하기 때문이다. 실수는 오차가 발생하기 때문에 더 높은 정밀도를 가지기 위해서는 double타입을 사용해야 한다.

## 실수형의 정밀도

실수형은 정수형과 달리 부동소수점 방식을 이용해서 값을 저장한다.  소수점의 위치를 지수(exponent)로 표현할 수 있다

`274,000,000,000,000은  +(부호) 2.74(가수) x 10^14 ( exponent = 14 : 지수)`

`0.00000000000274는  +(부호) 2.74(가수) x 10^-12 (exponent = -12 : 지수)`

실수형은 정밀도에 따라 오차가 발생한다. float는 정밀도가 7자리이다. 즉, 10진수로 7자리의 수를 오차없이 저장할 수 있고 double은 오차없이 15~16자리까지 오차없이 저장할 수 있다.

여기서 오차가 발생하는 이유는? 무한소수 때문이다. 3.14와 같이 무한소수이거나 10진수에는 유한소수이더라도 2진수로 변환하면 무한소수가 되는 경우들이 존재한다. 이럴경우 모든 자리수를 정확하게 표현하지 못하기때문에 오차가 발생한다.

즉, `한정된 메모리 공간`에서 무한의 실수를 표현하기 위해 `정밀도를 포기`하고 `표현의 범위`를 넓힌것이다.

```java
double doubleInput = 0.123456789123456789;
float  floatInput  = 0.123456789123456789f;

System.out.println(doubleInput);  // 0.12345678912345678
System.out.println(floatInput);   // 0.12345679 6자리까지 정확하게 표견 가능

double result = 0;

for (int i= 0; i<10; i++){
    testNum3 += 0.1;
}
System.out.println("result : " + testNum3); // 1이 나오지 않고 0.9999999999999999가 출력
```

## 참조형

- java.lang.Object를 상속받은경우 참조형이 된다. 기본형을 제외하면 모두 참조형이다.
- 실제 인스턴스는 힙에 생성되고, 힙 영역의 주소를 스택영역에서 저장하고 있다.

# 형변환

변환할 변수나 리터럴 앞에 타입을 괄호와 함께 붙여주면 된다. 기본형 데이터의경우 boolean을 제외하면 형변환이 가능하다. 하지만, 저장할 값이 범위를 초과한다면 값손실이 발생하기 때문에 에러가 발생한다. 이때, 명시적으로 어떤 형으로 변환할지 작성하면 컴파일러에서 에러가 발생하지 않는다. 

또한, 표현범위가 좁은타입에서 넓은타입으로 변환할때는 값 손실이 발생하지 않기 때문에 에러가 발생하지 않는다.

```java
double value = 123.456;
int score = (int)value;
System.out.println(value == 123.456); //true

byte b = 10000; //에러 발생. byte의 범위는 -128~127이다.
byte c = (byte)10000; //명시적 형변환으로 에러가 발생하지 않는다.
```